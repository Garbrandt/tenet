package servers

import (
	"encoding/json"
	"fmt"
	"github.com/Garbrandt/tenet/pkg/config"
	"github.com/gin-gonic/gin"
	"github.com/h2non/filetype"
	"github.com/jinzhu/gorm"
	uuid "github.com/satori/go.uuid"
	"io/ioutil"

	"github.com/Garbrandt/tenet/pkg/model"
	"net/http"
	"os"
	"path/filepath"
)

func (s *Server) UploadAttachments(c *gin.Context) {

	form, err := c.MultipartForm()
	if err != nil {
		c.String(http.StatusFailedDependency, fmt.Sprintf("files %s!", err.Error()))
		return
	}

	files := form.File["filepond"]
	if len(files) == 0 {
		c.String(http.StatusFailedDependency, fmt.Sprintf("no files "))
		return
	}

	for _, file := range files {
		id := uuid.NewV4().String()
		extension := filepath.Ext(file.Filename)
		filename := fmt.Sprintf("%s/%s%s", config.SiteAttachmentsPath, id, extension)
		err := c.SaveUploadedFile(file, filename)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"message": err.Error()})
			return
		}

		key := c.Param("section") + "#" + c.Param("env")
		content := model.Content{
			Key:           key,
			Title:         file.Filename,
			Type:          "attachments",
			Abstract:      "",
			ContentUrl:    "/attachments/" + id + extension,
			Body:          "",
			SourceUrl:     id + extension,
			CopyrightStat: "",
		}

		fi, err := os.Stat(filename)
		if err == nil {
			size := fi.Size()
			content.Size = size
		}

		buf, err := ioutil.ReadFile(filename)
		if err == nil {
			kind, err := filetype.Match(buf)
			if err == nil {
				if kind == filetype.Unknown {

				}
				content.Body = kind.MIME.Value
			}
		}

		result := s.DB.Create(&content)
		if result.Error != nil {
			continue
		}

		c.JSON(http.StatusOK, content)
		return
	}
}

func (s *Server) GetContentAttachments(c *gin.Context) {
	id := c.Param("id")
	section := c.Param("section")
	env := c.Param("env")
	connection := fmt.Sprintf("%s#%s", section, env)

	var contents []model.Content
	err := s.DB.Joins("JOIN connections ON connections.connection_content_id = contents.id").
		Where("connections.content_id = ? AND connections.connection_content_type = ? AND connections.deleted_at IS NULL",
			id, connection).Order("created_at DESC").Find(&contents).Error
	if err == gorm.ErrRecordNotFound || err != nil {
		return
	}

	var files = make([]model.FilePond, 0)
	for _, value := range contents {
		files = append(files, model.FilePond{
			ID:     value.ID,
			Source: "/attachments/" + value.SourceUrl,
			Options: struct {
				Type string `json:"type"`
			}{Type: "local"},
		})
	}

	c.JSON(http.StatusOK, files)
}

func (s *Server) GetAllOptions(c *gin.Context) {
	key := c.Param("section") + "#" + c.Param("env")

	var contents []model.Content
	err := s.DB.Debug().Where("key = ?", key).Order("created_at DESC").Find(&contents).Error
	if err == gorm.ErrRecordNotFound || err != nil {
		return
	}

	c.JSON(http.StatusOK, contents)
}

func (s *Server) DeleteAttachments(c *gin.Context) {
	body, err := ioutil.ReadAll(c.Request.Body)
	if err != nil {
		c.String(http.StatusUnprocessableEntity, "Delete failed")
		return
	}

	type AutoGenerated struct {
		ContentID    int `json:"content_id"`
		ConnectionID int `json:"connection_id"`
	}

	auto := AutoGenerated{}

	err = json.Unmarshal(body, &auto)
	if err != nil {
		c.JSON(http.StatusUnprocessableEntity, gin.H{
			"status": http.StatusUnprocessableEntity,
			"error":  err.Error(),
		})
		return
	}

	content := model.Content{}

	s.DB.Debug().Where("id = ?", auto.ContentID).First(&content)
	s.DB.Debug().Where("id = ?", auto.ContentID).Delete(&model.Content{})
	s.DB.Debug().Where("content_id = ? AND connection_content_id = ?", auto.ContentID, auto.ConnectionID).Delete(&model.Connection{})
	err = os.Remove(fmt.Sprintf("%s/%s", config.SiteAttachmentsPath, content.SourceUrl))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"message": err.Error()})
		return
	}
	return
}
